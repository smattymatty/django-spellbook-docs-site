{% extends 'examples/sb_base.html' %}

{% block spellbook_md %}
<h1>Progress SpellBlock (<code>~ progress ~</code>)</h1>
<p>The <code>~ progress ~</code> SpellBlock is a versatile tool for visualizing progress, completion percentage, skill level, funding status, or any value relative to a maximum. It provides a clear visual indicator that can be easily customized with an optional popover for additional context.</p>
<h2>Basic Usage</h2>
<p>At its simplest, provide a <code>value</code> (which defaults to being measured against a <code>max_value</code> of 100):</p>
<pre><code class="language-markdown">{~ progress value=&quot;65&quot; ~}
{~~}
</code></pre>
<p>This renders a progress bar showing 65%:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202871621048"
  >




  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-8 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-primary 
             sb-border-radius-md 

             " 
      role="progressbar"
      style="width: 65.0%;"
      aria-valuenow="65.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >



          <span class="sb-progress-label-internal sb-flex sb-text-center sb-black-75 
          sb-text-md
          sb-font-semibold sb-whitespace-nowrap sb-overflow-show sb-text-ellipsis sb-px-1">

            65.0%
          </span>


    </div>
  </div>
</div>
</p>
<h2>Parameters</h2>
<p>Customize the appearance and behavior using these parameters:</p>
<ul>
<li><strong><code>value</code></strong> (Required, Float/Int): The current value to display.</li>
<li><strong><code>max_value</code></strong> (Float/Int, Default: <code>100</code>): The maximum possible value. The bar's width is calculated as <code>(value / max_value) * 100</code>.</li>
<li><strong><code>label</code></strong> (String, Optional): Text displayed with the progress bar, often inside it. Supports variable interpolation (see below).</li>
<li><strong><code>show_percentage</code></strong> (Boolean, Default: <code>true</code> if <code>label</code> is not set, <code>false</code> otherwise): Determines if the percentage value is displayed inside the bar. This is overridden if <code>{{percentage}}</code> is used in the <code>label</code>.</li>
<li><strong><code>color</code></strong> (String, Default: <code>"primary"</code>): Sets the progress bar's fill color using predefined theme colors (e.g., <code>primary</code>, <code>secondary</code>, <code>success</code>, <code>info</code>, <code>warning</code>, <code>danger</code>, or even <code>white-25</code>, <code>black-75</code> for specific effects). Maps to <code>sb-bg-*</code> utility classes.</li>
<li><strong><code>bg_color</code></strong> (String, Default: <code>"white-50"</code>): Sets the track (background) color of the progress bar itself using predefined theme colors. Maps to <code>sb-bg-*</code> utility classes.</li>
<li><strong><code>height</code></strong> (String, Default: <code>"md"</code>): Adjusts the bar's height. Common values: <code>"sm"</code> (small), <code>"md"</code> (medium), <code>"lg"</code> (large). These map to utility classes like <code>sb-h-4</code>, <code>sb-h-8</code>, <code>sb-h-16</code> respectively in the provided template.</li>
<li><strong><code>striped</code></strong> (Boolean, Default: <code>false</code>): Adds a striped pattern to the bar's fill.</li>
<li><strong><code>animated</code></strong> (Boolean, Default: <code>false</code>): Animates the stripes (requires <code>striped="true"</code>).</li>
<li><strong><code>rounded</code></strong> (Boolean, Default: <code>true</code>): Applies rounded corners to the bar and track. Maps to <code>sb-border-radius-md</code> or similar.</li>
<li><strong><code>class</code></strong> (String, Optional): Adds custom CSS classes to the main container element (<code>.sb-progress-container</code>).</li>
<li><strong><code>id</code></strong> (String, Optional): Adds a custom HTML <code>id</code> attribute to the main container. Useful for specific targeting with CSS or JavaScript.</li>
<li>The content between <code>~ progress ... ~</code> and <code>~~</code> will be used for the popover when the progress bar is hovered.</li>
</ul>
<h2>Examples</h2>
<h3>Using Labels &amp; Colors</h3>
<p>Provide context and visual cues with <code>label</code> and <code>color</code>.</p>
<p><strong>Skill Proficiency:</strong><br />
The content between the tags will appear in a popover on hover.</p>
<pre><code class="language-markdown">{~ progress value=&quot;85&quot; label=&quot;Python Proficiency: {{percentage}}&quot; color=&quot;success&quot; height=&quot;sm&quot; ~}
Python is a powerful and versatile programming language. It is used in a wide range of applications, from web development to data analysis and machine learning.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202871971048"
  >




  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-4 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-success 
             sb-border-radius-md 

             " 
      role="progressbar"
      style="width: 85.0%;"
      aria-valuenow="85.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >



          <span class="sb-progress-label-internal sb-flex sb-text-center sb-black-75 
          sb-text-xs
          sb-font-semibold sb-whitespace-nowrap sb-overflow-show sb-text-ellipsis sb-px-1">

            Python Proficiency: 85.0
          </span>


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202871971048"
style="display: none;"
>
  <p>Python is a powerful and versatile programming language. It is used in a wide range of applications, from web development to data analysis and machine learning.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<p><strong>Changing Background Color:</strong><br />
Note how <code>color</code> affects the fill and <code>bg_color</code> affects the track.</p>
<pre><code class="language-markdown">{~ progress value=&quot;7500&quot; max_value=&quot;10000&quot; label=&quot;Raised: ${{value}} / ${{max_value}}&quot; color=&quot;white-25&quot; bg_color=&quot;black-75&quot; ~}
This project aims to raise $10,000 for new spellbook enchantments.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202872177748"
  >


    <div class="sb-progress-label-external sb-mb-1 
    sb-text-md
    ">
      Raised: $7500.0 / $10000.0
    </div>



  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-black-75 
           sb-h-8 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-white-25 
             sb-border-radius-md 

             " 
      role="progressbar"
      style="width: 75.0%;"
      aria-valuenow="75.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202872177748"
style="display: none;"
>
  <p>This project aims to raise $10,000 for new spellbook enchantments.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<p><strong>Course Progress:</strong></p>
<pre><code class="language-markdown">{~ progress value=&quot;3&quot; max_value=&quot;5&quot; label=&quot;Modules: {{value}} / {{max_value}}&quot; color=&quot;info&quot; ~}
You've completed 3 out of 5 modules. Keep up the great work!
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202872455948"
  >


    <div class="sb-progress-label-external sb-mb-1 
    sb-text-md
    ">
      Modules: 3.0 / 5.0
    </div>



  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-8 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-info 
             sb-border-radius-md 

             " 
      role="progressbar"
      style="width: 60.0%;"
      aria-valuenow="60.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202872455948"
style="display: none;"
>
  <p>You've completed 3 out of 5 modules. Keep up the great work!</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<h3>Using <code>max_value</code></h3>
<p>Track progress towards a specific goal other than 100.</p>
<p><strong>Fundraising Goal:</strong></p>
<pre><code class="language-markdown">{~ progress value=&quot;7500&quot; max_value=&quot;10000&quot; label=&quot;Raised: ${{value}} / ${{max_value}} ({{percentage}})&quot; color=&quot;primary&quot; rounded=&quot;false&quot; height=&quot;lg&quot; ~}
Current contributions for the new library wing.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202872709748"
  >




  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-16 
           " 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-primary 


             " 
      role="progressbar"
      style="width: 75.0%;"
      aria-valuenow="75.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >



          <span class="sb-progress-label-internal sb-flex sb-text-center sb-black-75 
          sb-text-lg
          sb-font-semibold sb-whitespace-nowrap sb-overflow-show sb-text-ellipsis sb-px-1">

            Raised: $7500.0 / $10000.0 (75.0)
          </span>


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202872709748"
style="display: none;"
>
  <p>Current contributions for the new library wing.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<h3>Striped &amp; Animated</h3>
<p>Add visual flair for active processes or goals.</p>
<p><strong>Processing Data:</strong></p>
<pre><code class="language-markdown">{~ progress value=&quot;45&quot; label=&quot;Processing... {{percentage}}&quot; color=&quot;warning&quot; striped=&quot;true&quot; animated=&quot;true&quot; ~}
Currently analyzing ancient scrolls. This may take a moment.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202872933848"
  >




  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-8 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-warning 
             sb-border-radius-md 
             sb-progress-bar-striped 
             sb-progress-bar-animated" 
      role="progressbar"
      style="width: 45.0%;"
      aria-valuenow="45.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >



          <span class="sb-progress-label-internal sb-flex sb-text-center sb-black-75 
          sb-text-md
          sb-font-semibold sb-whitespace-nowrap sb-overflow-show sb-text-ellipsis sb-px-1">

            Processing... 45.0
          </span>


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202872933848"
style="display: none;"
>
  <p>Currently analyzing ancient scrolls. This may take a moment.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<h3>Completion State</h3>
<p>Use <code>color="success"</code> for completed tasks.</p>
<p><strong>Task Complete:</strong></p>
<pre><code class="language-markdown">{~ progress value=&quot;100&quot; label=&quot;Deployment Successful!&quot; color=&quot;success&quot; ~}
The new enchantments have been successfully deployed to the live grimoire!
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202873095748"
  >


    <div class="sb-progress-label-external sb-mb-1 
    sb-text-md
    ">
      Deployment Successful!
    </div>



  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-8 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-success 
             sb-border-radius-md 

             " 
      role="progressbar"
      style="width: 100.0%;"
      aria-valuenow="100.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202873095748"
style="display: none;"
>
  <p>The new enchantments have been successfully deployed to the live grimoire!</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<h2>Label Interpolation</h2>
<p>The <code>label</code> parameter allows dynamic text using these placeholders:</p>
<ul>
<li><strong><code>{{value}}</code></strong>: Replaced with the raw <code>value</code> passed to the block.</li>
<li><strong><code>{{max_value}}</code></strong>: Replaced with the raw <code>max_value</code> passed to the block (or its default).</li>
<li><strong><code>{{percentage}}</code></strong>: Replaced with the calculated percentage (e.g., <code>75.0%</code>).</li>
</ul>
<div class="sb-alert sb-alert-info sb-p-3 sb-border-radius-lg sb-mb-3 sb-shadow-sm ">
    <span class="sb-alert-icon">

            ℹ️

    </span>
    <span class="sb-alert-content">
        <p>Using <code>{{percentage}}</code> in the <code>label</code> will typically cause the percentage value to be displayed inside the bar, even if <code>show_percentage</code> would otherwise default to <code>false</code>. Literal curly braces in other contexts within the label text should render as typed.</p>
    </span>
</div>

<h2>Height Adjustments &amp; Popover Content</h2>
<p>The content between the <code>progress</code> tags becomes the popover detail.</p>
<p><strong>Large Progress Bar with Details:</strong></p>
<pre><code class="language-markdown">{~ progress value=&quot;7500&quot; max_value=&quot;10000&quot; label=&quot;Raised: ${{value}} / ${{max_value}}&quot; color=&quot;info&quot; striped=&quot;true&quot; animated=&quot;true&quot; height=&quot;lg&quot; ~}
My content Here. It explains what this progress bar represents, providing more details on hover for the aspiring mage.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202873390548"
  >


    <div class="sb-progress-label-external sb-mb-1 
    sb-text-lg
    ">
      Raised: $7500.0 / $10000.0
    </div>



  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-white-50 
           sb-h-16 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-info 
             sb-border-radius-md 
             sb-progress-bar-striped 
             sb-progress-bar-animated" 
      role="progressbar"
      style="width: 75.0%;"
      aria-valuenow="75.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202873390548"
style="display: none;"
>
  <p>My content Here. It explains what this progress bar represents, providing more details on hover for the aspiring mage.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<p><strong>Small Progress Bar with Different Popover Style (Illustrative - popover style is global):</strong><br />
<em>Note: The popover's visual style (like background/text color) is generally global from the CSS. Specific parameters <code>content_bg_color</code> or <code>content_color</code> for the popover are not standard for this block unless you've custom-built that functionality.</em></p>
<pre><code class="language-markdown">{~ progress value=&quot;7500&quot; max_value=&quot;10000&quot; label=&quot;Raised: ${{value}} / ${{max_value}}&quot; color=&quot;error&quot; bg_color=&quot;neutral-25&quot; striped=&quot;true&quot; height=&quot;sm&quot; ~}
This indicates a critical funding shortfall! The popover will explain the dire consequences.
{~~}
</code></pre>
<p>Renders as:</p>
<p><div
  class="sb-progress-container sb-shadow-md sb-w-full "
  id="progress-container-174711202873542948"
  >


    <div class="sb-progress-label-external sb-mb-1 
    sb-text-xs
    ">
      Raised: $7500.0 / $10000.0
    </div>



  <div
    class="sb-progress sb-w-full sb-overflow-hidden 
           sb-bg-neutral-25 
           sb-h-4 
           sb-border-radius-md" 
  >

    <div
      class="sb-progress-bar sb-h-full sb-flex sb-items-center sb-justify-center 
             sb-bg-error 
             sb-border-radius-md 
             sb-progress-bar-striped 
             " 
      role="progressbar"
      style="width: 75.0%;"
      aria-valuenow="75.0"
      aria-valuemin="0"
      aria-valuemax="100"
    >


    </div>
  </div>
</div>
</p>
<div class="sb-progress-popover-content
sb-bg-white
sb-black
" 
id="popover-content-174711202873542948"
style="display: none;"
>
  <p>This indicates a critical funding shortfall! The popover will explain the dire consequences.</p>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle multiple progress bars on a page if `id` attribute might not be unique or forloop.counter is used
    const progressContainers = document.querySelectorAll('.sb-progress-container');

    progressContainers.forEach(container => {
      const containerId = container.id; // e.g., "progress-container-1"
      // Derive popoverId based on containerId. This assumes a consistent naming pattern.
      // If your id on sb-progress-container can be arbitrary (e.g., from block kwargs),
      // you might need a data-attribute to link them or adjust this logic.
      // For now, assuming the forloop.counter pattern in IDs.
      const popoverIdSuffix = containerId.split('-').pop(); // Extracts "1" from "progress-container-1"
      const popover = document.getElementById(`popover-content-${popoverIdSuffix}`);

      if (!popover) {
        // console.warn(`Popover not found for container ${containerId}`);
        return; // Skip if corresponding popover isn't found
      }

      let popoverVisible = false; // Track visibility to avoid redundant style changes

      container.addEventListener('mouseenter', function(event) {
        if (!popoverVisible) {
          popover.style.display = 'block';
          popover.classList.add('sb-animate-fade-in');
          popoverVisible = true;
        }
        // Initial position update on enter
        updatePopoverPosition(event);
      });

      container.addEventListener('mousemove', function(event) {
        if (popoverVisible) {
          updatePopoverPosition(event);
        }
      });

      container.addEventListener('mouseleave', function() {
        if (popoverVisible) {
          popover.style.display = 'none';
          popoverVisible = false;
        }
      });

      function updatePopoverPosition(mouseEvent) {
        // Offset from the mouse cursor
        const offsetX = 15; // pixels to the right
        const offsetY = 15; // pixels below

        let newX = mouseEvent.clientX + offsetX;
        let newY = mouseEvent.clientY + offsetY;

        // Boundary checks to keep popover within viewport
        const popoverRect = popover.getBoundingClientRect(); // Get its dimensions once visible

        // Adjust if too far right
        if (newX + popoverRect.width > window.innerWidth) {
          newX = mouseEvent.clientX - popoverRect.width - offsetX; // Position to the left
        }
        // Adjust if too far down
        if (newY + popoverRect.height > window.innerHeight) {
          newY = mouseEvent.clientY - popoverRect.height - offsetY; // Position above
        }
        // Adjust if too far left (after potentially flipping)
        if (newX < 0) {
          newX = offsetX;
        }
        // Adjust if too far up (after potentially flipping)
        if (newY < 0) {
          newY = offsetY;
        }

        popover.style.left = newX + 'px';
        popover.style.top = newY + 'px';
      }
    });
  });
  </script>

<hr />
{% endblock %}